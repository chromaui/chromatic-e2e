{"version":3,"sources":["../src/index.ts","../src/utils/logger.ts","../src/resource-archive/index.ts","../src/write-archive/index.ts","../src/playwright-api/takeArchive.ts","../src/utils/source-mapper.ts","../src/utils/analytics.ts","../src/playwright-api/makeTest.ts","../src/cypress-api/index.ts","../src/cypress-api/commands.ts"],"names":["base","expect","logger","_args","Watcher","page","networkTimeoutMs","globalNetworkTimeout","resolve","reject","networkIdlePromise","url","response","event","request","method","params","error","requestId","responseStatusCode","responseStatusText","responseErrorReason","responseHeaders","requestUrl","isLocalRequest","result","body","base64Encoded","contentTypeHeader","name","isFirstRequest","createResourceArchive","networkTimeout","watcher","mime","outputFile","ensureDir","outputJson","join","sanitize","string","writeTestResult","testInfo","domSnapshots","archive","chromaticStorybookParams","sourceMap","title","outputDir","finalOutputDir","archiveDir","pathname","fileName","fileExtension","writeSnapshotFiles","writeStoriesFile","errors","r","domSnapshot","mappedSnapshot","mapSourceEntries","jsonBuffer","bufferAsString","sourceVal","child","jsonString","mappedSourceEntriesBuffer","storiesFilename","readFileSync","dedent","NodeType","path","SourceMapper","maxLength","input","existingSourceMap","nextChildNode","srcAsString","pathPieces","rebuiltPieces","piece","index","stringBuffer","shortName","shortenedPath","childElementNode","rrweb","__require","contentType","takeArchive","nameOrTestInfo","maybeTestInfo","a","msg","Analytics","analytics","userId","track","properties","hasTrackedRun","trackRun","hasTrackedComplete","trackComplete","makeTest","delay","diffIncludeAntiAliasing","diffThreshold","disableAutoCapture","forcedColors","pauseAnimationAtEnd","prefersReducedMotion","resourceArchiveTimeout","use","completeArchive","resourceArchive","snapshots","doArchive","testTitle","bufferedArchiveList","key","value","allSnapshots","item","setupNetworkListener","pageUrl","req","doc","snap","manualSnapshots","archiveCypress","stuff","snapshot","addCommands","snappy","snappies","test"],"mappings":"6PAAA,OAAS,QAAQA,GAAM,UAAAC,OAAc,mBCA9B,IAAMC,EAAS,QAAQ,IAAI,IAC9B,QACA,CAAE,IAAK,IAAIC,IAAiB,CAAC,EAAG,KAAM,IAAIA,IAAiB,CAAC,CAAE,ECmBlE,IAAMC,EAAN,KAAc,CAoBZ,YAAoBC,EAAYC,EAAmB,IAA4C,CAA3E,UAAAD,EAnBpB,KAAO,QAA2B,CAAC,EAanC,KAAQ,OAAS,GAEjB,KAAQ,qBAA6D,KAKnE,KAAK,uBAAyBC,CAChC,CAEA,MAAM,OAAQ,CACZ,KAAK,OAAS,MAAM,KAAK,KAAK,QAAQ,EAAE,cAAc,KAAK,IAAI,EAE/D,KAAK,OAAO,GAAG,4BAA6B,KAAK,kBAAkB,KAAK,IAAI,CAAC,EAC7E,KAAK,OAAO,GAAG,2BAA4B,KAAK,iBAAiB,KAAK,IAAI,CAAC,EAC3E,KAAK,OAAO,GAAG,sBAAuB,KAAK,cAAc,KAAK,IAAI,CAAC,EAEnE,MAAM,KAAK,OAAO,KAAK,cAAc,CACvC,CAEA,MAAM,MAAO,CAMX,IAAMC,EAAuB,IAAI,QAAc,CAACC,EAASC,IAAW,CAElE,KAAK,sBAAwBD,EAE7B,KAAK,qBAAuB,WAAW,IAAM,CAC3CN,EAAO,KAAK,qBAAqB,KAAK,kCAAkC,EACxE,KAAK,sBAAsB,CAC7B,EAAG,KAAK,sBAAsB,CAChC,CAAC,EAIKQ,EAAqB,KAAK,KAAK,iBAAiB,aAAa,EAAE,QAAQ,IAAM,CACjF,aAAa,KAAK,oBAAoB,CACxC,CAAC,EAED,MAAM,QAAQ,KAAK,CAACH,EAAsBG,CAAkB,CAAC,EAE7DR,EAAO,IAAI,iBAAiB,EAC5B,KAAK,OAAS,EAChB,CAEA,YAAYS,EAAgBC,EAA2B,CACrD,KAAK,QAAQD,CAAG,EAAIC,CACtB,CAEA,kBAAkBC,EAAkD,CAClEX,EAAO,IAAI,mBAAmB,EAC9BA,EAAO,IAAIW,CAAK,CAClB,CAEA,iBAAiBA,EAAiD,CAChEX,EAAO,IAAI,kBAAkB,EAC7BA,EAAO,IAAIW,CAAK,CAClB,CAEA,MAAM,WACJC,EACAC,EACAC,EACiD,CACjD,GAAI,CACF,OAAO,MAAM,KAAK,OAAO,KAAKD,EAAQC,CAAM,CAC9C,OAASC,EAAP,CACA,OAAAf,EAAO,IAAI,eAAgBY,EAAQ,IAAKG,CAAK,EAC7C,KAAK,QAAQH,EAAQ,GAAG,EAAI,CAAE,MAAAG,CAAM,EAC7B,IACT,CACF,CAEA,MAAM,cAAc,CAClB,UAAAC,EACA,QAAAJ,EACA,mBAAAK,EACA,mBAAAC,EACA,oBAAAC,EACA,gBAAAC,CACF,EAAwC,CACtC,IAAMC,EAAa,IAAI,IAAIT,EAAQ,GAAG,EAEtC,KAAK,WAAL,KAAK,SAAaS,GAElB,IAAMC,EACJD,EAAW,WAAa,KAAK,SAAS,UACtCA,EAAW,OAAS,KAAK,SAAS,MAClCA,EAAW,OAAS,KAAK,SAAS,KAepC,GAbArB,EAAO,IACL,gBACAqB,EAAW,SAAS,EACpBJ,GAAsBE,EAAsB,WAAa,UACzD,KAAK,SAAS,SAAS,EACvBG,CACF,EAEI,KAAK,QACPtB,EAAO,IAAI,0BAA0B,EAInCmB,EAAqB,CACvBnB,EAAO,IAAI,uBAAuBmB,GAAqB,EACvD,MAAM,KAAK,WAAWP,EAAS,wBAAyB,CAAE,UAAAI,CAAU,CAAC,EACrE,OAIF,GAAIC,EAAoB,CACtB,GAAI,CAAC,IAAK,IAAK,IAAK,GAAG,EAAE,SAASA,CAAkB,EAAG,CACrD,MAAM,KAAK,WAAWL,EAAS,wBAAyB,CACtD,UAAAI,EACA,kBAAmB,EACrB,CAAC,EACD,OAGF,IAAMO,EAAS,MAAM,KAAK,WAAWX,EAAS,wBAAyB,CACrE,UAAAI,CACF,CAAC,EAED,GAAIO,IAAW,KACb,OAEF,GAAM,CAAE,KAAAC,EAAM,cAAAC,CAAc,EAAIF,EAG1BG,EAAgDN,EAAgB,KACpE,CAAC,CAAE,KAAAO,CAAK,IAAMA,IAAS,cACzB,EAGMC,EAAiBP,EAAW,SAAS,IAAM,KAAK,SAAS,SAAS,EACpEC,GAAkB,CAACM,IACrB,KAAK,QAAQhB,EAAQ,GAAG,EAAI,CAC1B,WAAYK,EACZ,WAAYC,EACZ,KAAM,OAAO,KAAKM,EAAMC,EAAgB,SAAW,MAAM,EACzD,YAAaC,CACf,GAGF,MAAM,KAAK,WAAWd,EAAS,wBAAyB,CAAE,UAAAI,CAAU,CAAC,EACrE,OAGF,IAAMN,EAAW,KAAK,QAAQE,EAAQ,GAAG,EACzC,GAAIF,GAAY,eAAgBA,EAAU,CACxCV,EAAO,IAAI,8DAA8D,EACzEA,EAAO,IAAI,CACT,UAAAgB,EACA,aAAcN,EAAS,WACvB,eAAgBA,EAAS,UAC3B,CAAC,EACD,MAAM,KAAK,WAAWE,EAAS,uBAAwB,CACrD,UAAAI,EACA,aAAcN,EAAS,WACvB,GAAIA,EAAS,YAAc,CAAE,eAAgBA,EAAS,UAAW,EAEjE,KAAMA,EAAS,KAAK,SAAS,QAAQ,CACvC,CAAC,EACD,OAGF,MAAM,KAAK,WAAWE,EAAS,wBAAyB,CACtD,UAAAI,EACA,kBAAmB,EACrB,CAAC,CACH,CACF,EAEA,eAAsBa,EACpB1B,EACA2B,EAAiB,IACwB,CACzC,IAAMC,EAAU,IAAI7B,EAAQC,EAAM2B,CAAc,EAChD,aAAMC,EAAQ,MAAM,EAEb,UACL,MAAMA,EAAQ,KAAK,EAEZA,EAAQ,QAEnB,CC/NA,OAAOC,MAAU,OAEjB,OAAS,cAAAC,EAAY,aAAAC,EAAW,cAAAC,MAAkB,WAClD,OAAS,QAAAC,MAAY,OAQd,IAAMC,EAAYC,GAErBA,EACG,YAAY,EAEZ,QAAQ,sDAAuD,GAAG,EAClE,QAAQ,MAAO,GAAG,EAClB,QAAQ,MAAO,EAAE,EACjB,QAAQ,MAAO,EAAE,EASxB,eAAsBC,EACpBC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,GAAM,CAAE,MAAAC,EAAO,UAAAC,CAAU,EAAIN,EAGvBO,EAAiBX,EAAKU,EAAW,KAAM,oBAAoB,EAE3DE,EAAaZ,EAAKW,EAAgB,SAAS,EAEjD,MAAMb,EAAUa,CAAc,EAE9B/C,EAAO,IAAI,6BAA6B6C,IAAQ,EAEhD,MAAM,QAAQ,IACZ,OAAO,QAAQH,CAAO,EAAE,IAAI,MAAO,CAACjC,EAAKC,CAAQ,IAAM,CACrD,GAAI,UAAWA,EAAU,OAEzB,GAAM,CAAE,SAAAuC,CAAS,EAAI,IAAI,IAAIxC,CAAG,EAE5ByC,EAAWD,EAAS,SAAS,GAAG,EAAI,GAAGA,cAAuBA,EAMlE,GALIL,EAAU,IAAIK,CAAQ,IACxBC,EAAWN,EAAU,IAAIK,CAAQ,GAI/BvC,EAAS,YAAa,CACxB,IAAMyC,EAAgBnB,EAAK,aAAatB,EAAS,YAAY,KAAK,EAC9DyC,IACFD,EAAW,GAAGA,KAAYC,IAEtBP,EAAU,IAAIK,CAAQ,GACxBL,EAAU,IAAIK,EAAUC,CAAQ,GAKtC,MAAMjB,EAAWG,EAAKY,EAAYE,CAAQ,EAAGxC,EAAS,IAAI,CAC5D,CAAC,CACH,EAEA,MAAM0C,EAAmBX,EAAcO,EAAYH,EAAOD,CAAS,EAEnE,MAAMS,EACJjB,EAAKW,EAAgB,GAAGV,EAASQ,CAAK,gBAAgB,EACtDA,EACAJ,EACAE,CACF,EAEA,IAAMW,EAAS,OAAO,QAAQZ,CAAO,EAAE,OAAO,CAAC,CAAC,CAAEa,CAAC,IAAM,UAAWA,CAAC,EACjED,EAAO,OAAS,IAClBtD,EAAO,IAAI,eAAesD,EAAO,6DAA6D,EAC9F,MAAMnB,EAAWC,EAAKY,EAAY,aAAa,EAAG,CAChD,OAAQ,OAAO,YAAYM,CAAM,CACnC,CAAC,EAEL,CAEA,eAAeF,EACbX,EACAO,EACAH,EACAD,EACA,CAEA,MAAM,OAAO,QAAQH,CAAY,EAAE,IAAI,MAAO,CAACd,EAAM6B,CAAW,IAAM,CAGpE,IAAMC,EAAiB,MAAMC,EAAiBF,EAAaZ,CAAS,EAEpE,MAAMX,EACJG,EAAKY,EAAY,GAAGX,EAASQ,CAAK,KAAKR,EAASV,CAAI,iBAAiB,EACrE8B,CACF,CACF,CAAC,CACH,CAUA,eAAeC,EAAiBF,EAAqBZ,EAAgC,CACnF,IAAIe,EACJ,GAAI,OAAO,SAASH,CAAW,EAAG,CAChC,IAAMI,EAAiBJ,EAAY,SAAS,OAAO,EAInD,GAAI,CACFG,EAAa,KAAK,MAAMC,CAAc,CACxC,MAAE,CACA,OAAOJ,CACT,OAEAG,EAAaH,EAGf,GAAIG,EAAW,YAAcA,EAAW,WAAW,IAAK,CACtD,IAAME,EAAYF,EAAW,WAAW,IACpCf,EAAU,IAAIiB,CAAS,IACzBF,EAAW,WAAW,IAAMf,EAAU,IAAIiB,CAAS,GAIvD,OAAIF,EAAW,aACbA,EAAW,WAAa,MAAM,QAAQ,IACpCA,EAAW,WAAW,IAAI,MAAOG,GAAU,CACzC,IAAMC,EAAa,KAAK,UAAUD,CAAK,EACjCE,EAA4B,MAAMN,EACtC,OAAO,KAAKK,CAAU,EACtBnB,CACF,EAEA,OAD4B,KAAK,MAAMoB,EAA0B,SAAS,OAAO,CAAC,CAEpF,CAAC,CACH,GAGK,OAAO,KAAK,KAAK,UAAUL,CAAU,CAAC,CAC/C,CAEA,eAAeN,EACbY,EACApB,EACAJ,EACAE,EACA,CACA3C,EAAO,IAAI,WAAWiE,GAAiB,EACvC,MAAM9B,EAAW8B,EAAiB,CAChC,MAAApB,EACA,QAAS,OAAO,KAAKJ,CAAY,EAAE,IAAKd,IAAU,CAChD,KAAAA,EACA,WAAY,CACV,OAAQ,CAAE,GAAI,GAAGU,EAASQ,CAAK,KAAKR,EAASV,CAAI,iBAAkB,EACnE,UAAW,CACT,GAAGgB,CACL,CACF,CACF,EAAE,CACJ,CAAC,CACH,CChLA,OAAS,gBAAAuB,MAAoB,KAG7B,OAAOC,MAAY,YCHnB,OAAS,YAAAC,MAAgB,2BACzB,OAAOC,MAAU,OAQV,IAAMC,EAAN,KAAmB,CAWxB,YAAYd,EAA0B,CACpC,KAAK,YAAcA,EACnB,KAAK,wBAA0B,EACjC,CAaA,2BAA2Be,EAAiC,CAC1D,YAAK,wBAA0BA,EAExB,IACT,CAQA,OAA6B,CAC3B,IAAM3B,EAAY,IAAI,IACtB,OAAI,KAAK,wBAA0B,GAAK,KAAK,YAAY,WAChD,KAAK,+BAA+B,KAAK,YAAY,WAAYA,CAAS,EAG5EA,CACT,CAEQ,+BACN4B,EACAC,EACqB,CAErB,QAAWC,KAAiBF,EAAO,CACjC,GAAI,eAAgBE,GAAiB,QAASA,EAAc,WAAY,CACtE,IAAMC,EAAsBD,EAAc,WAAW,IAG/CE,EAAcF,EAAc,WAAW,IAAe,MAAM,GAAG,EAC/DG,EAA+B,CAAC,EAEtCD,EAAW,QAAQ,CAACE,EAAOC,IAAU,CACnC,IAAMC,EAAe,OAAO,KAAKF,CAAK,EAClCG,EAAoBH,EACpBE,EAAa,OAAS,KAAK,0BAC7BC,EAAYD,EAAa,SAAS,QAAS,EAAG,KAAK,uBAAuB,EAC1EhF,EAAO,IACL,sBAAsBgF,kCAA6CC,IACrE,GAGFJ,EAAc,KAAKI,CAAS,CAC9B,CAAC,EAGD,IAAMC,EAAgB,GAAGP,EAAY,WAAW,GAAG,EAAI,IAAM,KAAKN,EAAK,KACrE,GAAGQ,CACL,IACAJ,EAAkB,IAAIE,EAAaO,CAAa,EAGlD,GAAIR,EAAc,OAASN,EAAS,QAAS,CAC3C,IAAMe,EAAgCT,EAElCS,EAAiB,WAAW,SAAW,GACzC,KAAK,+BAA+BA,EAAiB,WAAYV,CAAiB,GAKxF,OAAOA,CACT,CACF,ED7FA,IAAMW,EAAQlB,EACZmB,EAAQ,QAAQ,iDAAiD,EACjE,MACF,EAEaC,EAAc,kCAQ3B,eAAeC,EACbpF,EACAqF,EACAC,EAC8B,CAC9B,IAAI9D,EACAa,EACJ,GAAI,OAAOgD,GAAmB,SAAU,CACtC,GAAI,CAACC,EAAe,MAAM,IAAI,MAAM,iBAAiB,EACrDjD,EAAWiD,EACX9D,EAAO6D,OAEPhD,EAAWgD,EAEX7D,EAAO,aADQa,EAAS,YAAY,OAAQkD,GAAMA,EAAE,cAAgBJ,CAAW,EAAE,OAAS,IAI5FnF,EAAK,GAAG,UAAYwF,GAAQ,CAC1B3F,EAAO,IAAI,aAAa2F,EAAI,KAAK,IAAI,CACvC,CAAC,EAGD,IAAMnC,EAA2B,MAAMrD,EAAK,SAASgE;AAAA,MACjDiB;AAAA;AAAA,GAEH,EAOKxC,EAD6B,IAAI0B,EAAad,CAAW,EAChC,2BAA2B,GAAG,EAAE,MAAM,EAErE,OAAAhB,EAAS,OAAOb,EAAM,CAAE,YAAA2D,EAAa,KAAM,KAAK,UAAU9B,CAAW,CAAE,CAAC,EAEjE,QAAQ,QAAQZ,CAAS,CAClC,CE3DA,OAAS,aAAAgD,MAA8B,0BAEvC,IAAMC,EAAY,IAAID,EAAU,CAC9B,SAAU,QAAQ,IAAI,mBAAqB,kCAC7C,CAAC,EAGKE,EAAS,8BAER,SAASC,EAAMpF,EAAeqF,EAAuC,CAC1EH,EAAU,MAAM,CAAE,OAAAC,EAAQ,MAAAnF,EAAO,WAAAqF,CAAW,CAAC,CAC/C,CAEA,IAAIC,EAAgB,GACb,SAASC,EAASF,EAAwC,CAAC,EAAG,CAC/DC,IACJF,EAAM,MAAOC,CAAU,EACvBC,EAAgB,GAClB,CAEA,IAAIE,EAAqB,GAClB,SAASC,EAAcJ,EAAwC,CAAC,EAAG,CACpEG,IACJJ,EAAM,WAAYC,CAAU,EAC5BG,EAAqB,GACvB,CCNO,IAAME,EACXvG,GAKAA,EAAK,OAAyC,CAE5C,MAAO,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EACnC,wBAAyB,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EACrD,cAAe,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EAC3C,mBAAoB,CAAC,GAAO,CAAE,OAAQ,EAAK,CAAC,EAC5C,aAAc,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EAC1C,oBAAqB,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EACjD,qBAAsB,CAAC,OAAW,CAAE,OAAQ,EAAK,CAAC,EAClD,uBAAwB,CAAC,IAA4C,CAAE,OAAQ,EAAK,CAAC,EAErF,KAAM,CACJ,MACE,CACE,KAAAK,EACA,MAAAmG,EACA,wBAAAC,EACA,cAAAC,EACA,mBAAAC,EACA,aAAAC,EACA,oBAAAC,EACA,qBAAAC,EACA,uBAAAC,CACF,EACAC,EACAtE,IACG,CAOH,GANA0D,EAAS,EAML/F,EAAK,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,KAAK,IAAM,WAAY,CAChE,MAAM2G,EAAI,EACV,OAGF,IAAMC,EAAkB,MAAMlF,EAAsB1B,EAAM0G,CAAsB,EAChF,MAAMC,EAAI,EAEV,IAAIlE,EACC6D,IACH7D,EAAY,MAAM2C,EAAYpF,EAAMqC,CAAQ,GAG9C,IAAMwE,EAAkB,MAAMD,EAAgB,EAExCE,EAAY,OAAO,YACvBzE,EAAS,YACN,OAAQkD,GAAMA,EAAE,cAAgBJ,GAAe,CAAC,CAACI,EAAE,IAAI,EACvD,IAAI,CAAC,CAAE,KAAA/D,EAAM,KAAAH,CAAK,IAAM,CAACG,EAAMH,CAAI,CAAC,CACzC,EAEMmB,EAA2B,CAC/B,GAAI2D,GAAS,CAAE,MAAAA,CAAM,EACrB,GAAIC,GAA2B,CAAE,wBAAAA,CAAwB,EACzD,GAAIC,GAAiB,CAAE,cAAAA,CAAc,EACrC,GAAIE,GAAgB,CAAE,aAAAA,CAAa,EACnC,GAAIC,GAAuB,CAAE,oBAAAA,CAAoB,EACjD,GAAIC,GAAwB,CAAE,qBAAAA,CAAqB,EACnD,UAAW,CAACzG,EAAK,aAAa,EAAE,KAAK,CACvC,EAEA,MAAMoC,EACJC,EACAyE,EACAD,EACArE,EACAC,CACF,EAEAwD,EAAc,CAChB,EACA,CAAE,KAAM,EAAK,CACf,CACF,CAAC,EChGI,IAAMc,EAAY,MAAO,CAC9B,UAAAC,EACA,aAAA1E,EACA,gBAAAuE,EACA,yBAAArE,CACF,IAAM,CACJ,IAAIC,EAAwC,KAExCH,EAAa,OAAS,IAGxBG,EADmC,IAAI0B,EAAa7B,EAAaA,EAAa,OAAS,CAAC,CAAC,EAChE,2BAA2B,GAAG,EAAE,MAAM,GAGjE,IAAM2E,EAAsB,OAAO,QAAQJ,CAAe,EAAE,IAAI,CAAC,CAACK,EAAKC,CAAK,IACnE,CACLD,EACA,CACE,GAAGC,EAGH,KAAM,OAAO,KAAKA,EAAM,KAAM,MAAM,CACtC,CACF,CACD,EAEKC,EAAe,OAAO,YAC1B9E,EAAa,IAAI,CAAC+E,EAAMzC,IAAU,CAAC,aAAaA,EAAQ,IAAK,OAAO,KAAK,KAAK,UAAUyC,CAAI,CAAC,CAAC,CAAC,CACjG,EAEA,MAAMjF,EACJ,CACE,MAAO4E,EAEP,UAAW,QACb,EACAI,EACA,OAAO,YAAYH,CAAmB,EACtC,CAAE,GAAGzE,EAA0B,SAAU,CAAE,MAAO,IAAK,OAAQ,GAAI,CAAE,EACrEC,CACF,CACF,EAEa6E,EAAuB,IAAM,CACxC,IAAIC,EAAsB,KAC1B,GAAG,KAAK,CAAC,CAAC,EAAE,GAAG,SAAS,EACxB,GAAG,KAAK,CAAC,CAAC,EAAE,GAAG,iBAAiB,EAGhC,GAAG,UAAU,OAASC,GAAQ,CAG5B,GAAI,CAACD,EAAS,CACZA,EAAU,IAAI,IAAIC,EAAI,GAAG,EACzB,OAGU,IAAI,IAAIA,EAAI,GAAG,EACnB,SAAWD,EAAQ,SAO3B,OAAOC,EAAI,QAAQ,eAAe,EAGlC,OAAOA,EAAI,QAAQ,mBAAmB,EACtCA,EAAI,SAAUjH,GAAa,CACzB,GAAG,IAAI,UAAU,EAAE,KAAMgC,GAAY,CAEnCA,EAAQhC,EAAS,GAAG,EAAI,CACtB,WAAYA,EAAS,WACrB,WAAYA,EAAS,cACrB,KAAMA,EAAS,IACjB,CACF,CAAC,CACH,CAAC,EACH,CAAC,CACH,EAEaqG,EAAkB,IAAM,CACnC,GAAG,IAAI,UAAU,EAAE,KAAMrE,GAAY,CAEnC,GAAG,SAAS,EAAE,KAAMkF,GAAQ,CAE1B,IAAMC,EAAO,SAASD,EAAK,CAAE,WAAY,EAAK,CAAC,EAC/C,GAAG,IAAI,kBAAkB,EAAE,KAAK,CAACE,EAAkB,CAAC,IAAM,CAExD,GAAG,KAAK,iBAAkB,CACxB,UAAW,QAAQ,YAAY,MAC/B,aAAc,CAAC,GAAGA,EAAiBD,CAAI,EACvC,gBAAiBnF,EACjB,yBAA0B,CACxB,cAAe,QAAQ,IAAI,eAAe,CAC5C,CACF,CAAC,CACH,CAAC,CACH,CAAC,CACH,CAAC,CACH,EAEaqF,GAAkBC,IAE7Bd,EAAUc,CAAK,EACR,MC7GT,OAAS,YAAAC,OAAgB,2BAElB,IAAMC,GAAc,IAAM,CAC/B,QAAQ,SAAS,IAAI,cAAe,IAAM,CACxC,GAAG,SAAS,EAAE,KAAMN,GAAQ,CAE1B,IAAMO,EAASF,GAASL,EAAK,CAAE,WAAY,EAAK,CAAC,EAEjD,GAAG,IAAI,kBAAkB,EACtB,KAAMQ,GAAa,CAAC,GAAGA,EAAUD,CAAM,CAAC,EACxC,GAAG,iBAAiB,CACzB,CAAC,CACH,CAAC,CACH,ETXO,IAAME,GAAOhC,EAASvG,EAAI","sourcesContent":["import { test as base, expect } from '@playwright/test';\n\nimport { makeTest } from './playwright-api/makeTest';\n\nexport const test = makeTest(base);\n\nexport { expect };\n\nexport { archiveCypress, setupNetworkListener, completeArchive } from './cypress-api';\nexport { addCommands } from './cypress-api/commands';\n\nexport { takeArchive } from './playwright-api/takeArchive';\nexport type { ChromaticConfig } from './types';\n","export const logger = process.env.LOG\n  ? console\n  : { log: (..._args: any[]) => {}, warn: (..._args: any[]) => {} };\n","import type { CDPSession, Page } from 'playwright';\nimport type { Protocol } from 'playwright-core/types/protocol';\nimport { logger } from '../utils/logger';\n\nimport { DEFAULT_GLOBAL_RESOURCE_ARCHIVE_TIMEOUT_MS } from '../constants';\n\ntype UrlString = string;\n\ntype ArchiveResponse =\n  | {\n      statusCode: number;\n      statusText?: string;\n      body: Buffer;\n      contentType: Protocol.Fetch.HeaderEntry;\n    }\n  | {\n      error: Error;\n    };\n\nexport type ResourceArchive = Record<UrlString, ArchiveResponse>;\n\nclass Watcher {\n  public archive: ResourceArchive = {};\n\n  private client: CDPSession;\n\n  private globalNetworkTimeoutMs;\n\n  /**\n   * We assume the first URL loaded after @watch is called is the base URL of the\n   * page and we only save resources that are loaded from the same protocol/host/port combination.\n   * We also skip archiving this page because we only care about resources requested by this page.\n   */\n  private firstUrl: URL;\n\n  private closed = false;\n\n  private globalNetworkTimerId: null | ReturnType<typeof setTimeout> = null;\n\n  private globalNetworkResolver: () => void;\n\n  constructor(private page: Page, networkTimeoutMs = DEFAULT_GLOBAL_RESOURCE_ARCHIVE_TIMEOUT_MS) {\n    this.globalNetworkTimeoutMs = networkTimeoutMs;\n  }\n\n  async watch() {\n    this.client = await this.page.context().newCDPSession(this.page);\n\n    this.client.on('Network.requestWillBeSent', this.requestWillBeSent.bind(this));\n    this.client.on('Network.responseReceived', this.responseReceived.bind(this));\n    this.client.on('Fetch.requestPaused', this.requestPaused.bind(this));\n\n    await this.client.send('Fetch.enable');\n  }\n\n  async idle() {\n    // XXX_jwir3: The way this works is as follows:\n    // There are two promises created here. They wrap two separate timers, and we await on a race of both Promises.\n\n    // The first promise wraps a global timeout, where all requests MUST complete before that timeout has passed.\n    // If the timeout passes, an error is thrown. This promise can only throw errors, it cannot resolve successfully.\n    const globalNetworkTimeout = new Promise<void>((resolve, reject) => {\n      // this.globalNetworkRejector = reject;\n      this.globalNetworkResolver = resolve;\n\n      this.globalNetworkTimerId = setTimeout(() => {\n        logger.warn(`Global timeout of ${this.globalNetworkTimeoutMs}ms reached`);\n        this.globalNetworkResolver();\n      }, this.globalNetworkTimeoutMs);\n    });\n\n    // The second promise wraps a network idle timeout. This uses playwright's built-in functionality to detect when the network\n    // is idle.\n    const networkIdlePromise = this.page.waitForLoadState('networkidle').finally(() => {\n      clearTimeout(this.globalNetworkTimerId);\n    });\n\n    await Promise.race([globalNetworkTimeout, networkIdlePromise]);\n\n    logger.log('Watcher closing');\n    this.closed = true;\n  }\n\n  setResponse(url: UrlString, response: ArchiveResponse) {\n    this.archive[url] = response;\n  }\n\n  requestWillBeSent(event: Protocol.Network.requestWillBeSentPayload) {\n    logger.log('requestWillBeSent');\n    logger.log(event);\n  }\n\n  responseReceived(event: Protocol.Network.responseReceivedPayload) {\n    logger.log('responseReceived');\n    logger.log(event);\n  }\n\n  async clientSend<T extends keyof Protocol.CommandParameters>(\n    request: Protocol.Network.Request,\n    method: T,\n    params?: Protocol.CommandParameters[T]\n  ): Promise<Protocol.CommandReturnValues[T] | null> {\n    try {\n      return await this.client.send(method, params);\n    } catch (error) {\n      logger.log('Client error', request.url, error);\n      this.archive[request.url] = { error };\n      return null;\n    }\n  }\n\n  async requestPaused({\n    requestId,\n    request,\n    responseStatusCode,\n    responseStatusText,\n    responseErrorReason,\n    responseHeaders,\n  }: Protocol.Fetch.requestPausedPayload) {\n    const requestUrl = new URL(request.url);\n\n    this.firstUrl ??= requestUrl;\n\n    const isLocalRequest =\n      requestUrl.protocol === this.firstUrl.protocol &&\n      requestUrl.host === this.firstUrl.host &&\n      requestUrl.port === this.firstUrl.port;\n\n    logger.log(\n      'requestPaused',\n      requestUrl.toString(),\n      responseStatusCode || responseErrorReason ? 'response' : 'request',\n      this.firstUrl.toString(),\n      isLocalRequest\n    );\n\n    if (this.closed) {\n      logger.log('Watcher closed, ignoring');\n    }\n\n    // Pausing at response stage with an error, simply ignore\n    if (responseErrorReason) {\n      logger.log(`Got response error: ${responseErrorReason}`);\n      await this.clientSend(request, 'Fetch.continueRequest', { requestId });\n      return;\n    }\n\n    // Pausing a response stage with a response\n    if (responseStatusCode) {\n      if ([301, 302, 307, 308].includes(responseStatusCode)) {\n        await this.clientSend(request, 'Fetch.continueRequest', {\n          requestId,\n          interceptResponse: true,\n        });\n        return;\n      }\n\n      const result = await this.clientSend(request, 'Fetch.getResponseBody', {\n        requestId,\n      });\n      // Something has gone wrong and will be logged above\n      if (result === null) {\n        return;\n      }\n      const { body, base64Encoded } = result;\n\n      // If the Content-Type header is present, let's capture it.\n      const contentTypeHeader: Protocol.Fetch.HeaderEntry = responseHeaders.find(\n        ({ name }) => name === 'Content-Type'\n      );\n\n      // No need to capture the response of the top level page request\n      const isFirstRequest = requestUrl.toString() === this.firstUrl.toString();\n      if (isLocalRequest && !isFirstRequest) {\n        this.archive[request.url] = {\n          statusCode: responseStatusCode,\n          statusText: responseStatusText,\n          body: Buffer.from(body, base64Encoded ? 'base64' : 'utf8'),\n          contentType: contentTypeHeader,\n        };\n      }\n\n      await this.clientSend(request, 'Fetch.continueRequest', { requestId });\n      return;\n    }\n\n    const response = this.archive[request.url];\n    if (response && 'statusCode' in response) {\n      logger.log(`pausing request we've seen before, sending previous response`);\n      logger.log({\n        requestId,\n        responseCode: response.statusCode,\n        responsePhrase: response.statusText,\n      });\n      await this.clientSend(request, 'Fetch.fulfillRequest', {\n        requestId,\n        responseCode: response.statusCode,\n        ...(response.statusText && { responsePhrase: response.statusText }),\n        // responseHeaders: response.headers, TODO - mapping\n        body: response.body.toString('base64'),\n      });\n      return;\n    }\n\n    await this.clientSend(request, 'Fetch.continueRequest', {\n      requestId,\n      interceptResponse: true,\n    });\n  }\n}\n\nexport async function createResourceArchive(\n  page: Page,\n  networkTimeout = DEFAULT_GLOBAL_RESOURCE_ARCHIVE_TIMEOUT_MS\n): Promise<() => Promise<ResourceArchive>> {\n  const watcher = new Watcher(page, networkTimeout);\n  await watcher.watch();\n\n  return async () => {\n    await watcher.idle();\n\n    return watcher.archive;\n  };\n}\n","import mime from 'mime';\n\nimport { outputFile, ensureDir, outputJson } from 'fs-extra';\nimport { join } from 'path';\nimport type { TestInfo } from '@playwright/test';\nimport type { elementNode } from '@chromaui/rrweb-snapshot';\nimport { logger } from '../utils/logger';\nimport type { ResourceArchive } from '../resource-archive';\nimport type { ChromaticStorybookParameters } from '../types';\n\n// @storybook/csf's sanitize function, we could import this\nexport const sanitize = (string: string) => {\n  return (\n    string\n      .toLowerCase()\n      // eslint-disable-next-line no-useless-escape\n      .replace(/[ ’–—―′¿'`~!@#$%^&*()_|+\\-=?;:'\",.<>\\{\\}\\[\\]\\\\\\/]/gi, '-')\n      .replace(/-+/g, '-')\n      .replace(/^-+/, '')\n      .replace(/-+$/, '')\n  );\n};\n\n// We write a collection of DOM snapshots and a resource archive in the following locations:\n// <test-title>.stories.json\n// archive/<test-title>.json\n// archive/<file>.<ext>\n\nexport async function writeTestResult(\n  testInfo: TestInfo,\n  domSnapshots: Record<string, Buffer>,\n  archive: ResourceArchive,\n  chromaticStorybookParams: ChromaticStorybookParameters,\n  sourceMap: Map<string, string>\n) {\n  const { title, outputDir } = testInfo;\n  // outputDir gives us the test-specific subfolder (https://playwright.dev/docs/api/class-testconfig#test-config-output-dir);\n  // we want to write one level above that\n  const finalOutputDir = join(outputDir, '..', 'chromatic-archives');\n\n  const archiveDir = join(finalOutputDir, 'archive');\n\n  await ensureDir(finalOutputDir);\n\n  logger.log(`Writing test results for \"${title}\"`);\n\n  await Promise.all(\n    Object.entries(archive).map(async ([url, response]) => {\n      if ('error' in response) return;\n\n      const { pathname } = new URL(url);\n\n      let fileName = pathname.endsWith('/') ? `${pathname}index.html` : pathname;\n      if (sourceMap.has(pathname)) {\n        fileName = sourceMap.get(pathname);\n      }\n\n      // Let's add an extension to this, if it's a file.\n      if (response.contentType) {\n        const fileExtension = mime.getExtension(response.contentType.value);\n        if (fileExtension) {\n          fileName = `${fileName}.${fileExtension}`;\n\n          if (sourceMap.has(pathname)) {\n            sourceMap.set(pathname, fileName);\n          }\n        }\n      }\n\n      await outputFile(join(archiveDir, fileName), response.body);\n    })\n  );\n\n  await writeSnapshotFiles(domSnapshots, archiveDir, title, sourceMap);\n\n  await writeStoriesFile(\n    join(finalOutputDir, `${sanitize(title)}.stories.json`),\n    title,\n    domSnapshots,\n    chromaticStorybookParams\n  );\n\n  const errors = Object.entries(archive).filter(([, r]) => 'error' in r);\n  if (errors.length > 0) {\n    logger.log(`Encountered ${errors.length} errors archiving resources, writing to 'errors.json'`);\n    await outputJson(join(archiveDir, `errors.json`), {\n      errors: Object.fromEntries(errors),\n    });\n  }\n}\n\nasync function writeSnapshotFiles(\n  domSnapshots: Record<string, Buffer>,\n  archiveDir: string,\n  title: string,\n  sourceMap: Map<string, string>\n) {\n  // The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Object\n  await Object.entries(domSnapshots).map(async ([name, domSnapshot]) => {\n    // XXX_jwir3: We go through our stories here and map any instances that are found in\n    //            the keys of the source map to their respective values.\n    const mappedSnapshot = await mapSourceEntries(domSnapshot, sourceMap);\n\n    await outputFile(\n      join(archiveDir, `${sanitize(title)}-${sanitize(name)}.snapshot.json`),\n      mappedSnapshot\n    );\n  });\n}\n/**\n * Accepts a DOM snapshot, which is either a `Buffer` or an object in json form, and maps all `src` attributes that are equivalent to\n * one of the entries in the `sourceMap` to the resulting value.\n *\n * @param domSnapshot The DOM snapshot upon which to run the mapping, as a Buffer\n * @param sourceMap A mapping of `string` objects to other `string` objects. All `src` attributes that are keys in this map will be\n *                  adjusted to be the resulting value.\n * @returns A JSON string representing the mapped DOM snapshot.\n */\nasync function mapSourceEntries(domSnapshot: Buffer, sourceMap: Map<string, string>) {\n  let jsonBuffer: elementNode;\n  if (Buffer.isBuffer(domSnapshot)) {\n    const bufferAsString = domSnapshot.toString('utf-8');\n\n    // Try to parse as JSON. Our tests don't always return JSON, so this is kind of a hack\n    // to avoid a situation where JSON is expected but not actually given.\n    try {\n      jsonBuffer = JSON.parse(bufferAsString);\n    } catch (err) {\n      return domSnapshot;\n    }\n  } else {\n    jsonBuffer = domSnapshot;\n  }\n\n  if (jsonBuffer.attributes && jsonBuffer.attributes.src) {\n    const sourceVal = jsonBuffer.attributes.src as string;\n    if (sourceMap.has(sourceVal)) {\n      jsonBuffer.attributes.src = sourceMap.get(sourceVal);\n    }\n  }\n\n  if (jsonBuffer.childNodes) {\n    jsonBuffer.childNodes = await Promise.all(\n      jsonBuffer.childNodes.map(async (child) => {\n        const jsonString = JSON.stringify(child);\n        const mappedSourceEntriesBuffer = await mapSourceEntries(\n          Buffer.from(jsonString),\n          sourceMap\n        );\n        const mappedSourceEntries = JSON.parse(mappedSourceEntriesBuffer.toString('utf-8'));\n        return mappedSourceEntries;\n      })\n    );\n  }\n\n  return Buffer.from(JSON.stringify(jsonBuffer));\n}\n\nasync function writeStoriesFile(\n  storiesFilename: string,\n  title: string,\n  domSnapshots: Record<string, Buffer>,\n  chromaticStorybookParams: ChromaticStorybookParameters\n) {\n  logger.log(`Writing ${storiesFilename}`);\n  await outputJson(storiesFilename, {\n    title,\n    stories: Object.keys(domSnapshots).map((name) => ({\n      name,\n      parameters: {\n        server: { id: `${sanitize(title)}-${sanitize(name)}.snapshot.json` },\n        chromatic: {\n          ...chromaticStorybookParams,\n        },\n      },\n    })),\n  });\n}\n","import type { Page, TestInfo } from '@playwright/test';\nimport { readFileSync } from 'fs';\nimport type { elementNode, serializedNodeWithId } from '@chromaui/rrweb-snapshot';\n\nimport dedent from 'ts-dedent';\n\nimport { SourceMapper } from '../utils/source-mapper';\nimport { logger } from '../utils/logger';\n\nconst rrweb = readFileSync(\n  require.resolve('@chromaui/rrweb-snapshot/dist/rrweb-snapshot.js'),\n  'utf8'\n);\n\nexport const contentType = 'application/rrweb.snapshot+json';\n\nasync function takeArchive(page: Page, testInfo: TestInfo): Promise<Map<string, string>>;\nasync function takeArchive(\n  page: Page,\n  name: string,\n  testInfo: TestInfo\n): Promise<Map<string, string>>;\nasync function takeArchive(\n  page: Page,\n  nameOrTestInfo: string | TestInfo,\n  maybeTestInfo?: TestInfo\n): Promise<Map<string, string>> {\n  let name: string;\n  let testInfo: TestInfo;\n  if (typeof nameOrTestInfo === 'string') {\n    if (!maybeTestInfo) throw new Error('Incorrect usage');\n    testInfo = maybeTestInfo;\n    name = nameOrTestInfo;\n  } else {\n    testInfo = nameOrTestInfo;\n    const number = testInfo.attachments.filter((a) => a.contentType === contentType).length + 1;\n    name = `Snapshot #${number}`;\n  }\n\n  page.on('console', (msg) => {\n    logger.log(`CONSOLE: \"${msg.text()}\"`);\n  });\n\n  // Serialize and capture the DOM\n  const domSnapshot: elementNode = await page.evaluate(dedent`\n    ${rrweb};\n    rrwebSnapshot.snapshot(document, { noAbsolute: true });\n  `);\n\n  // XXX_jwir3: We go through and filter any of these that would have file names that would be too long.\n  //            This is limited to 250 bytes. Technically, the file system is limited to 256 bytes, but\n  //            this gives us 5 bytes for a period and four characters, in the event that we want to\n  //            add a file extension.\n  const sourceMapper: SourceMapper = new SourceMapper(domSnapshot);\n  const sourceMap = sourceMapper.shortenFileNamesLongerThan(250).build();\n\n  testInfo.attach(name, { contentType, body: JSON.stringify(domSnapshot) });\n\n  return Promise.resolve(sourceMap);\n}\n\nexport { takeArchive };\n","import type { elementNode, serializedNodeWithId } from '@chromaui/rrweb-snapshot';\nimport { NodeType } from '@chromaui/rrweb-snapshot';\nimport path from 'path';\nimport { logger } from './logger';\n\n/**\n * A builder class that allows us to transform \"src\" entries within dom snapshots output\n * by `rrweb-snapshot`. This is done for post-processing of the data to avoid issues\n * where the \"src\" entry would not work well with the underlying file system.\n */\nexport class SourceMapper {\n  private domSnapshot: elementNode;\n\n  private shortenedFileNameLength: number;\n\n  /**\n   * Create a new {@link SourceMapper} object at a given root node.\n   *\n   * @param domSnapshot The {@link elementNode} where processing should start. This can be the dom\n   * snapshot that's retrieved when `rrweb-snapshot` is first invoked.\n   */\n  constructor(domSnapshot: elementNode) {\n    this.domSnapshot = domSnapshot;\n    this.shortenedFileNameLength = -1;\n  }\n\n  /**\n   * Specify a maximum length, in bytes, that any individual source path component can be.\n   *\n   * Note: Since \"src\" entries are assumed to be URIs (either in absolute or relative form),\n   * the separator for individual path components will always be '/'.\n   *\n   * @param maxLength A {@link number} that specifies the maximum number of bytes that can\n   * be used for each individual path component within an initial \"src\" entry.\n   *\n   * @returns `this`, the {@link SourceMapper} object upon which the method was called, for chaining.\n   */\n  shortenFileNamesLongerThan(maxLength: number): SourceMapper {\n    this.shortenedFileNameLength = maxLength;\n\n    return this;\n  }\n\n  /**\n   * Perform all scheduled post-processing and retrieve the mapping of source entries.\n   *\n   * @returns A {@link Map} of src entries, as they show up in the original dom snapshot data, to the\n   * transformed versions we need to use.\n   */\n  build(): Map<string, string> {\n    const sourceMap = new Map<string, string>();\n    if (this.shortenedFileNameLength > 0 && this.domSnapshot.childNodes) {\n      return this.shortenFileNameSourceRecursive(this.domSnapshot.childNodes, sourceMap);\n    }\n\n    return sourceMap;\n  }\n\n  private shortenFileNameSourceRecursive(\n    input: Array<serializedNodeWithId>,\n    existingSourceMap: Map<string, string>\n  ): Map<string, string> {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const nextChildNode of input) {\n      if ('attributes' in nextChildNode && 'src' in nextChildNode.attributes) {\n        const srcAsString: string = nextChildNode.attributes.src as string;\n\n        // Split this path to get all of the pieces\n        const pathPieces = (nextChildNode.attributes.src as string).split('/');\n        const rebuiltPieces: Array<string> = [];\n        // Shorten each individual piece\n        pathPieces.forEach((piece, index) => {\n          const stringBuffer = Buffer.from(piece);\n          let shortName: string = piece;\n          if (stringBuffer.length > this.shortenedFileNameLength) {\n            shortName = stringBuffer.toString('utf-8', 0, this.shortenedFileNameLength);\n            logger.log(\n              `Chunk of filename '${stringBuffer}' is too long. Shortening to '${shortName}'`\n            );\n          }\n\n          rebuiltPieces.push(shortName);\n        });\n\n        // Re-join the pieces and put this into the map\n        const shortenedPath = `${srcAsString.startsWith('/') ? '/' : ''}${path.join(\n          ...rebuiltPieces\n        )}`;\n        existingSourceMap.set(srcAsString, shortenedPath);\n      }\n\n      if (nextChildNode.type === NodeType.Element) {\n        const childElementNode: elementNode = nextChildNode as elementNode;\n\n        if (childElementNode.childNodes.length !== 0) {\n          this.shortenFileNameSourceRecursive(childElementNode.childNodes, existingSourceMap);\n        }\n      }\n    }\n\n    return existingSourceMap;\n  }\n}\n","import { Analytics, TrackParams } from '@segment/analytics-node';\n\nconst analytics = new Analytics({\n  writeKey: process.env.SEGMENT_WRITE_KEY || 'cwWhBWso2gwzyenW29CnCp30Kjz4DogE',\n});\n\n// We don't attempt to identify users\nconst userId = '@chromaui/test-archiver run';\n\nexport function track(event: string, properties: TrackParams['properties']) {\n  analytics.track({ userId, event, properties });\n}\n\nlet hasTrackedRun = false;\nexport function trackRun(properties: TrackParams['properties'] = {}) {\n  if (hasTrackedRun) return;\n  track('run', properties);\n  hasTrackedRun = true;\n}\n\nlet hasTrackedComplete = false;\nexport function trackComplete(properties: TrackParams['properties'] = {}) {\n  if (hasTrackedComplete) return;\n  track('complete', properties);\n  hasTrackedComplete = true;\n}\n","import type {\n  TestType,\n  PlaywrightTestArgs,\n  PlaywrightTestOptions,\n  PlaywrightWorkerArgs,\n  PlaywrightWorkerOptions,\n} from '@playwright/test';\nimport type { ChromaticConfig, ChromaticStorybookParameters } from '../types';\nimport { createResourceArchive } from '../resource-archive';\nimport { writeTestResult } from '../write-archive';\nimport { contentType, takeArchive } from './takeArchive';\nimport { trackComplete, trackRun } from '../utils/analytics';\nimport { DEFAULT_GLOBAL_RESOURCE_ARCHIVE_TIMEOUT_MS } from '../constants';\n\n// We do this slightly odd thing (makeTest) to avoid importing playwright multiple times when\n// linking this package. To avoid the main entry, you can:\n//\n//   import { makeTest } from '@chromaui/test-archiver/src/playwright-api/makeTest';\n//   import { takeSnapshot as snapshot } from '@chromaui/test-archiver/src/playwright-api/takeSnapshot';\nexport const makeTest = (\n  base: TestType<\n    PlaywrightTestArgs & PlaywrightTestOptions,\n    PlaywrightWorkerArgs & PlaywrightWorkerOptions\n  >\n) =>\n  base.extend<ChromaticConfig & { save: void }>({\n    // ChromaticConfig defaults\n    delay: [undefined, { option: true }],\n    diffIncludeAntiAliasing: [undefined, { option: true }],\n    diffThreshold: [undefined, { option: true }],\n    disableAutoCapture: [false, { option: true }],\n    forcedColors: [undefined, { option: true }],\n    pauseAnimationAtEnd: [undefined, { option: true }],\n    prefersReducedMotion: [undefined, { option: true }],\n    resourceArchiveTimeout: [DEFAULT_GLOBAL_RESOURCE_ARCHIVE_TIMEOUT_MS, { option: true }],\n\n    save: [\n      async (\n        {\n          page,\n          delay,\n          diffIncludeAntiAliasing,\n          diffThreshold,\n          disableAutoCapture,\n          forcedColors,\n          pauseAnimationAtEnd,\n          prefersReducedMotion,\n          resourceArchiveTimeout,\n        },\n        use,\n        testInfo\n      ) => {\n        trackRun();\n\n        // CDP only works in Chromium, so we only capture archives in Chromium.\n        // We can later snapshot them in different browsers in the cloud.\n        // TODO: I'm not sure if this is the best way to detect the browser version, but\n        // it seems to work\n        if (page.context().browser().browserType().name() !== 'chromium') {\n          await use();\n          return;\n        }\n\n        const completeArchive = await createResourceArchive(page, resourceArchiveTimeout);\n        await use();\n\n        let sourceMap;\n        if (!disableAutoCapture) {\n          sourceMap = await takeArchive(page, testInfo);\n        }\n\n        const resourceArchive = await completeArchive();\n\n        const snapshots = Object.fromEntries(\n          testInfo.attachments\n            .filter((a) => a.contentType === contentType && !!a.body)\n            .map(({ name, body }) => [name, body])\n        ) as Record<string, Buffer>;\n\n        const chromaticStorybookParams = {\n          ...(delay && { delay }),\n          ...(diffIncludeAntiAliasing && { diffIncludeAntiAliasing }),\n          ...(diffThreshold && { diffThreshold }),\n          ...(forcedColors && { forcedColors }),\n          ...(pauseAnimationAtEnd && { pauseAnimationAtEnd }),\n          ...(prefersReducedMotion && { prefersReducedMotion }),\n          viewports: [page.viewportSize().width],\n        };\n\n        await writeTestResult(\n          testInfo,\n          snapshots,\n          resourceArchive,\n          chromaticStorybookParams,\n          sourceMap\n        );\n\n        trackComplete();\n      },\n      { auto: true },\n    ],\n  });\n","// @ts-nocheck\n\nimport { writeTestResult } from '../write-archive';\nimport { SourceMapper } from '../utils/source-mapper';\n\nexport const doArchive = async ({\n  testTitle,\n  domSnapshots,\n  resourceArchive,\n  chromaticStorybookParams,\n}) => {\n  let sourceMap: Map<string, string> | null = null;\n\n  if (domSnapshots.length > 0) {\n    // shortens file names in the last snapshot (which is the automatic one)\n    const sourceMapper: SourceMapper = new SourceMapper(domSnapshots[domSnapshots.length - 1]);\n    sourceMap = sourceMapper.shortenFileNamesLongerThan(250).build();\n  }\n\n  const bufferedArchiveList = Object.entries(resourceArchive).map(([key, value]) => {\n    return [\n      key,\n      {\n        ...value,\n        // we can't use Buffer in the browser (when we collect the responses)\n        // so we go through one by one here and bufferize them\n        body: Buffer.from(value.body, 'utf8'),\n      },\n    ];\n  });\n\n  const allSnapshots = Object.fromEntries(\n    domSnapshots.map((item, index) => [`Snapshot #${index + 1}`, Buffer.from(JSON.stringify(item))])\n  ) as Record<string, Buffer>;\n\n  await writeTestResult(\n    {\n      title: testTitle,\n      // doesn't matter what value we put here, as long as it's a subdirectory of where we want this to actually go\n      outputDir: './some',\n    },\n    allSnapshots,\n    Object.fromEntries(bufferedArchiveList),\n    { ...chromaticStorybookParams, viewport: { width: 500, height: 500 } },\n    sourceMap\n  );\n};\n\nexport const setupNetworkListener = () => {\n  let pageUrl: URL | null = null;\n  cy.wrap({}).as('archive');\n  cy.wrap([]).as('manualSnapshots');\n\n  // since we don't know where the user will navigate, we'll archive whatever domain they're on first.\n  cy.intercept(`**/*`, (req) => {\n    // don't archive the page itself -- we'll do that with rrweb\n    // TODO: See if this will work for both slash and not slash endings or if we have to do same \"first URL visited\" stuff\n    if (!pageUrl) {\n      pageUrl = new URL(req.url);\n      return;\n    }\n\n    const url = new URL(req.url);\n    if (url.origin !== pageUrl.origin) {\n      return;\n    }\n\n    // cached (304) responses don't provide a body, so we need to make sure cache is blown away\n    // (https://glebbahmutov.com/blog/cypress-intercept-problems/#cached-response)\n    // https://github.com/cypress-io/cypress/issues/15680\n    delete req.headers['if-none-match'];\n    // I added this since some css files still are cached... not sure if this is great\n    // (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304)\n    delete req.headers['if-modified-since'];\n    req.continue((response) => {\n      cy.get('@archive').then((archive) => {\n        // eslint-disable-next-line no-param-reassign\n        archive[response.url] = {\n          statusCode: response.statusCode,\n          statusText: response.statusMessage,\n          body: response.body,\n        };\n      });\n    });\n  });\n};\n\nexport const completeArchive = () => {\n  cy.get('@archive').then((archive) => {\n    // can we be sure this always fires after all the requests are back?\n    cy.document().then((doc) => {\n      // here, handle the source map\n      const snap = snapshot(doc, { noAbsolute: true });\n      cy.get('@manualSnapshots').then((manualSnapshots = []) => {\n        // pass the snapshot to the server to write to disk\n        cy.task('archiveCypress', {\n          testTitle: Cypress.currentTest.title,\n          domSnapshots: [...manualSnapshots, snap],\n          resourceArchive: archive,\n          chromaticStorybookParams: {\n            diffThreshold: Cypress.env('diffThreshold'),\n          },\n        });\n      });\n    });\n  });\n};\n\nexport const archiveCypress = (stuff) => {\n  // https://docs.cypress.io/api/commands/task#Usage\n  doArchive(stuff);\n  return null;\n};\n","// @ts-nocheck\n\nimport { snapshot } from '@chromaui/rrweb-snapshot';\n\nexport const addCommands = () => {\n  Cypress.Commands.add('takeArchive', () => {\n    cy.document().then((doc) => {\n      // here, handle the source map\n      const snappy = snapshot(doc, { noAbsolute: true });\n      // reassign manualSnapshots so it includes this new element\n      cy.get('@manualSnapshots')\n        .then((snappies) => [...snappies, snappy])\n        .as('manualSnapshots');\n    });\n  });\n};\n"]}